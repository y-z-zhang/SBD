%% Simultaneous Block Diagonalization of multiple matrices
%%                      by Yuanzhao Zhang (yuanzhao@u.northwestern.edu)

%%%%%%%%
%PURPOSE
%%%%%%%%
%% This code finds a finest simultaneous block diagonalization (SBD) of a set of
%% symmetric or hermitian matrices A within the field \mathbb{R} or \mathbb{C}.
%% It also works for generic matrices (not necessarily symmetric or hermitian),
%% in such cases the SBD is the finest in the sense of matrix *-algebras.

%%%%%%%
%USEAGE
%%%%%%%
%% [P,BlockSizes] = sbd(A,field,threshold)
%% A --- cell array containing the set of matrices to be simultaneously block diagonalized
%% field --- 'real' or 'complex'
%% threshold --- error tolerance when sorting the blocks (suitable choice makes the algorithm robust against noise in matrix data)
%% P --- orthogonal/unitary transformation matrix that performs SBD on A
%% BlockSizes --- array listing the size of each common block

%%%%%%%%%%
%REFERENCE
%%%%%%%%%%
%% Y. Zhang, V. Latora, and A. E. Motter, "Unified Treatment of Dynamical Processes on Higher-order, Multilayer, and Temporal Networks"

function [P,BlockSizes] = sbd(A,field,threshold)

  n = size(A{1},2);  %% size of the matrices to be simultaneously block diagonalized
  BlockSizes = [];   %% initialize the array that lists the size of each common block

  %% B is a random self-adjoint matrix generated by matrices from A (and their conjugate transposes)
  B = zeros(n);
  for p = 1:size(A,2)
    switch field
      case 'real'
        B = B + randn*(A{p}+(A{p})');
      case 'complex'
        B = B + randn*(A{p}+(A{p})') + i*randn*(A{p}-(A{p})');
    end
  end

  %% find the eigenvalues and eigenvectors of B
  [V,D] = eig(B);

  %% C is a matrix used to sort the column vectors of V (i.e., the base vectors)
  %% such that the base vectors corresponding to the same common block are next to each other
  C = zeros(n);
  for p = 1:size(A,2)
    C = C + randn*V'*A{p}*V;
  end

  %% arrays used to track which base vectors have been sorted
  remaining_basis = 1:n;
  sorted_basis = [];

  %% the sorting process: find C_ij's that are nonzero and group the base vectors v_i and v_j together
  while ~isempty(remaining_basis)
    current_block = 1;
    current_block_size = 1;
    if length(remaining_basis) > 1
      for k = 2:length(remaining_basis)
        if abs(C(remaining_basis(1),remaining_basis(k))) > threshold | abs(C(remaining_basis(k),remaining_basis(1))) > threshold
          current_block = [current_block,k];
          current_block_size = current_block_size + 1;
        end
      end
    end
    sorted_basis = [sorted_basis,remaining_basis(current_block)];
    remaining_basis(current_block) = [];
    BlockSizes = [BlockSizes,current_block_size];
  end

%% the sorted base vectors give the final orthogonal/unitary transformation matrix that performs SBD on A
P = V(:,sorted_basis);

end
